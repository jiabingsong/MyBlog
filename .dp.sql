/*
SQLyog Ultimate v12.08 (64 bit)
MySQL - 8.0.18 : Database - tumo
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`tumo` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `tumo`;

/*Table structure for table `tb_article` */

DROP TABLE IF EXISTS `tb_article`;

CREATE TABLE `tb_article` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `title` varchar(400) DEFAULT NULL COMMENT '标题',
  `cover` varchar(400) DEFAULT NULL COMMENT '封面图片',
  `author` varchar(100) NOT NULL COMMENT '作者',
  `content` mediumtext COMMENT '内容',
  `content_md` mediumtext COMMENT '内容-Markdown',
  `category` varchar(20) DEFAULT NULL COMMENT '分类',
  `origin` varchar(100) DEFAULT NULL COMMENT '来源',
  `state` varchar(100) NOT NULL COMMENT '状态',
  `publish_time` datetime DEFAULT NULL COMMENT '发布时间',
  `edit_time` datetime NOT NULL COMMENT '上次修改时间',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `type` int(11) DEFAULT '0' COMMENT '类型， 0原创 1转载',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 COMMENT='文章表';

/*Data for the table `tb_article` */

insert  into `tb_article`(`id`,`title`,`cover`,`author`,`content`,`content_md`,`category`,`origin`,`state`,`publish_time`,`edit_time`,`create_time`,`type`) values (1,'SpringBoot简介',NULL,'ppsong','虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是XML配置。Spring2.5引入基于注解的组件扫描，这消除了大量针对相应用程序自身组件的显示XML配置。Spring3.0引入了基于Java的配置，这是一种类型，安全的可重构配置方式，可以代替XML。\r\n\r\n所有这些配置都代表了开发的损耗。因为在思考Spring的特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。\r\n\r\n除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本随之而来的不兼容问题就会严重阻碍项目的开发进度','# Spring优缺点分析\r\n## Spring优点分析\r\n  Spring是Java企业版（Java Enterprise Edition,JEE,也称J2EE）的轻量级的代替品。无需开发重量级的Enterprise JavaBean(EJB),Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object,POJO）实现了EJB的功能。    \r\n\r\n## Spring缺点分析\r\n  虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是XML配置。Spring2.5引入基于注解的组件扫描，这消除了大量针对相应用程序自身组件的显示XML配置。Spring3.0引入了基于Java的配置，这是一种类型，安全的可重构配置方式，可以代替XML。  \r\n\r\n\r\n  所有这些配置都代表了开发的损耗。因为在思考Spring的特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。  \r\n\r\n\r\n  除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本随之而来的不兼容问题就会严重阻碍项目的开发进度。   \r\n\r\n\r\n# SpringBoot的概述\r\n## SpringBoot解决上述Spring的缺点\r\n  SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。  \r\n\r\n\r\n## SpringBoot的特点\r\n  1.为基于Spring的开发提供更快的入门体验  \r\n  2.开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求  \r\n  3.提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标、健康检测、外部配置等  \r\n  4.SpringBoot不是对Spring功能上的增强，而且提供了一种快速使用Spring的方式   \r\n\r\n\r\n## SpringBoot的核心功能  \r\n  1.起步依赖：  \r\n    起步依赖本质上是一个Maven项目对象模型（Project Object Model，PDM）定义了对其他库的传递依赖，这些东西加在一起即支持某功能。  \r\n\r\n  2.自动配置：\r\n    SpringBoot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个。该过程是Spring自动完成的。\r\n',NULL,NULL,'1','2020-06-19 12:40:49','2020-06-19 12:40:53','2020-06-19 12:40:56',5),(2,'SpringBoot整合Mybatis',NULL,'ppsong',NULL,'# SpringBoot整合Mybatis\r\n我们在使用SpringBoot的时候会连接数据库使用其中的数据。首先我们要建立一个SpringBoot的项目详见<http://songjiabing.top/2020/02/02/SpringBoot快速入门/>\r\n## 添加Mybatis的起步依赖 \r\n在pom.xml文件中添加 \r\n```xml\r\n <!--mybatis起步依赖-->\r\n        <dependency>\r\n            <groupId>org.mybatis.spring.boot</groupId>\r\n            <artifactId>mybatis-spring-boot-starter</artifactId>\r\n            <version>1.1.1</version>\r\n        </dependency>\r\n```\r\n\r\n## 添加数据库驱动坐标(以MySQL为例)\r\n在pom.xml文件中添加\r\n```xml\r\n<!--MySQL连接驱动-->\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n        </dependency>\r\n```\r\n\r\n## 添加数据库连接信息\r\n在src/main/resources下新建application.properties文件 \r\n```properties\r\n#数据库连接信息\r\nspring.datasource.driver-Class-Name=com.mysql.jdbc.Driver\r\nspring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf8&serverTimezone = GMT\r\nspring.datasource.username=root\r\nspring.datasource.password=password\r\n```\r\n\r\n## 创建user表（以MySQL为例）\r\n在mysql中的test数据库中添加user表查询语句如下：\r\n```mysql\r\nDROP TABLE IF EXISTS `user`;\r\nCREATE TABLE `user` (\r\n`id` INT(11) NOT NULL AUTO_INCREMENT,\r\n`username` VARCHAR(50) DEFAULT NULL,\r\n`password` VARCHAR(50) DEFAULT NULL,\r\n`name` VARCHAR(50) DEFAULT NULL,\r\nPRIMARY KEY (`id`)\r\n) ENGINE=INNODB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;\r\n\r\n\r\nINSERT INTO `user` VALUES (\'1\', \'ppsong\', \'123\', \'ppsong\');\r\nINSERT INTO `user` VALUES (\'2\', \'zlj\', \'123\', \'znj\');\r\n\r\n```\r\n\r\n## 创建实体Bean \r\n在src/main/java/com.xxx下新建domain包并建立User类,对user表中的元素一一对应并生成getter，setter和toString方法。   \r\n```java\r\npackage com.ppsong.domain;\r\n\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 21:03 2020/2/5\r\n * @Modified By:\r\n */\r\npublic class User {\r\n    private Integer id;\r\n    private String username;\r\n    private String password;\r\n    private String name;\r\n\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getUsername() {\r\n        return username;\r\n    }\r\n\r\n    public void setUsername(String username) {\r\n        this.username = username;\r\n    }\r\n\r\n    public String getPassword() {\r\n        return password;\r\n    }\r\n\r\n    public void setPassword(String password) {\r\n        this.password = password;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"User{\" +\r\n                \"id=\" + id +\r\n                \", username=\'\" + username + \'\\\'\' +\r\n                \", password=\'\" + password + \'\\\'\' +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 编写Mapper\r\n在src/main/java/com.xxx/下新建mapper包并在其下新建UserMapper功能接口\r\n```java\r\npackage com.ppsong.mapper;\r\n\r\nimport com.ppsong.domain.User;\r\nimport org.apache.ibatis.annotations.Mapper;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 21:19 2020/2/5\r\n * @Modified By:\r\n */\r\n@Mapper\r\npublic interface UserMapper {\r\n    public List<User> queryUserList();\r\n}\r\n\r\n```\r\n注：@Mapper标记该类是一个mybatis的mapper接口，可以被springboot自动扫描到spring上下文中\r\n\r\n## 配置Mapper映射文件  \r\n在src/main/resources下新建mapper包并在其下新建UserMapper.xml内容如下：\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybayis.org/dtd/mybatis-3-mapper.dtd\" >\r\n<mapper namespace=\"com.ppsong.mapper.UserMapper\">\r\n    <select id=\"queryUserList\" resultType=\"user\">\r\n        select * from user\r\n    </select>\r\n</mapper>\r\n```\r\n注：在mapper namespace=\"填写Mapper的功能接口所在的位置\"  \r\n\r\n## 在application.properties中添加mybatis  \r\n在src/main/resources/application.properties中添加\r\n```properties\r\n#配置mybatis的信息\r\n#pojo别名扫描包\r\nmybatis.type-aliases-package=com.ppsong.domain\r\n#加载mybatis映射文件\r\nmybatis.mapper-locations=classpath:mapper/*Mapper.xml\r\n```\r\n\r\n## 编写测试Controller \r\n在src/main/java/com.xxx/controller/下新建MybatisController.class\r\n```java\r\npackage com.ppsong.controller;\r\n\r\nimport com.ppsong.domain.User;\r\nimport com.ppsong.mapper.UserMapper;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 21:41 2020/2/5\r\n * @Modified By:\r\n */\r\n@Controller\r\npublic class MybatisController {\r\n\r\n    @Autowired\r\n    private UserMapper userMapper;\r\n\r\n    @RequestMapping(\"/query\")\r\n    @ResponseBody\r\n    public List<User> queryUserList() {\r\n        List<User> users = userMapper.queryUserList();\r\n        return users;\r\n    }\r\n}\r\n```\r\n\r\n## 测试\r\n启动进程我们可以在浏览器中输入localhost:8080/query/查看数据库的信息是否被显示。\r\n',NULL,NULL,'1','2020-06-19 20:51:03','2020-06-19 20:51:07','2020-06-19 20:51:10',5),(3,'String类常用方法',NULL,'ppsong',NULL,'\r\n# String类常用方法\r\nString作为一个类，那它也存在多种方法，我们可以调用类中方法来方便我们对字符串更好的处理。  \r\n## Java api文档\r\n在线文档：<https://docs.oracle.com/javase/10/docs/api/overview-summary.html>\r\n百度云下载：<https://pan.baidu.com/s/1maVj86VpZ1J3YbQzwRyvig>\r\n密码：0x33  \r\n在Java api文档中对一个类的介绍分为：\r\n                    类的完整定义  \r\n                    类相关说明信息  \r\n                    成员属性摘要  \r\n                    构造方法摘要（含有Deprecated描述的方法表示不建议使用）  \r\n                    普通方法摘要（左边为返回值 右边为方法名称和相应的参数） \r\n                    详细的说明  \r\n## 字符串与字符  \r\n可用方法：\r\n|NO.|方法名称|类型|描述|\r\n|:----:|:----|:----:|:----|\r\n|1|public String(char[] value)|构造|将传入的全部字符数组变为字符串|\r\n|2|public String(int[] codePoints,int offset,int count)|构造|将部分字符数组变为字符串|\r\n|3|public char charAt(int index)|普通|获取指定索引位置的字符|\r\n|4|public char[] toCharArray()|普通|将字符串中的数据以字符数组的形式返回|\r\n代码展示：\r\n大小字母转换与判断字符串是否都为数字  \r\n```java\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 23:01 2019/11/2\r\n * @Modified By:\r\n */\r\npublic class StringDemo {\r\n    public static void main(String[] args) {\r\n        String str =  \"i love you\";                  //实例化String类对象str\r\n        char[] result = str.toCharArray();           //引用toCharArray()方法将str转换为result数组\r\n        for (int x = 0; x < result.length; x++) {    //将数组中小写字母变为大写字母\r\n            if (result[x] >= \'a\' && result[x] <= \'z\') {\r\n                result[x] -= 32;\r\n            }\r\n        }\r\n        String newStr = new String(result);          //引用public String(char[] value)构造方法将result数组变为字符串\r\n        System.out.println(newStr);\r\n        System.out.println(new String(result, 2, 4));/*引用public String(int[] codePoints,int offset,int count)构造方法将数组部分变为字符串*/\r\n        System.out.println(isNumber(\"I miss you\") ? \"由数字所组成\" : \"不是由数字组成\");\r\n        System.out.println(isNumber(\"1234\") ? \"由数字所组成\" : \"不是由数字组成\");\r\n    }\r\n    /**\r\n     *@Description: \r\n     *Param: \r\n     *return: \r\n     *Author: PPsong\r\n     *Date: 2019/11/3\r\n     * 判断字符串中是否都为数字\r\n     */\r\n    public static boolean isNumber(String str) {\r\n        char[] result = str.toCharArray();           //将str字符串转换为字符数组\r\n        for (int x = 0; x < result.length; x++) {    //对数组的每一个字符进行判断\r\n            if (result[x] < \'0\' || result[x] > \'9\') {//判断是否为数字，有一不是即返回false\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n/**\r\n *I LOVE YOU\r\n *LOVE\r\n *不是由数字组成\r\n *由数字所组成\r\n */\r\n```\r\n## 字符串与字节\r\n可用方法：\r\n|NO.|方法名称|类型|描述|\r\n|:----:|:----|:----:|:----|\r\n|1|public String(byte[] bytes)|构造|将全部字节数组变为字符串|\r\n|2|public String(byte[] bytes,int offset,int length)|构造|将部分字节数组变为字符串|\r\n|3|public byte[] getBytes()|普通|将字符串变为字节数组|\r\n|4|public byte[] getBytes(String charsetName)throws UnsupportedEncodingException|普通|编码转换|\r\n字节数组与字符数组相似引用方法也类似在池此不做过多演示，但是字节数组范围要大于字符数组，可以用来表示汉字。\r\n## 字符串比较\r\n可以方法：\r\n|NO.|方法名称|类型|描述|\r\n|:----:|:----|:----:|:----|\r\n|1|public boolean equals(String anObject)|普通|区分大小写的相等判断|\r\n|2|public boolean equalsIgnoreCase(String anotherString)|普通|不区分大小写比较|\r\n|3|public int compareTo(String anotherString)|普通|判断两个字符串的大小（按照字符编码比较），此方法的返回值有三种结果：>0,<0,=0|\r\n|4|public int compareToIgnoreCase(String str)|普通|不区分大小写进行字符串大小的比较| \r\n代码： \r\n ```java\r\npublic class StringDemo {\r\n    public static void main(String[] args) {\r\n        String str =  \"ppsong\";                               //实例化String类对象str\r\n        String strA = null;\r\n        String strB = \"PPsong\";\r\n        System.out.println(\"PPSONG\".equals(str));             //内容比较false\r\n        System.out.println(\"PPSONG\".equalsIgnoreCase(str));   //忽略大小写内容比较true\r\n        System.out.println((\"ppsong\").equals(strA));          //equals方法可以避空false\r\n        System.out.println(str.compareTo(strB));              //32大于0\r\n        System.out.println(strB.compareTo(str));              //-32小于0\r\n        System.out.println(str.compareToIgnoreCase(strB));    //不区分大小写等于0\r\n    }\r\n\r\n ```\r\n## 字符串查找\r\n可用方法：\r\n|NO.|方法名称|类型|描述|\r\n|:----:|:----|:----:|:----|\r\n|1|public boolean contains(String s)|普通|判断字符串是否存在|\r\n|2|public int indexOf(String str)|普通|从头查找指定字符串的位置，找不到返回-1|\r\n|3|public int indexOf(String str,int fromIndex)|普通|从指定位置向后查找指定字符串的位置|\r\n|4|public int lastIndexOf(String str)|普通|由后查找指定字符串的位置，找不到返回-1|\r\n|5|public int lastIndexOf(String str,int fromIndex)|普通|从指定位置向前查找指定字符串的位置|\r\n|6|public boolean startsWith(String prefix)|普通|判断是否以指定的字符串开头|\r\n|7|public boolean startsWith(String prefix,int toffset)|普通|由指定位置判断是否以指定的字符串开头|\r\n|8|public boolean endsWith(String suffix)|普通|判断是否以指定的字符串开头|\r\n代码所示:\r\n```java\r\npublic class StringDemo {\r\n    public static void main(String[] args) {\r\n        String strA = \"I miss you\";\r\n        String strB = \"http://www.songjiabing.top\";\r\n        System.out.println(strA.contains(\"you\"));\r\n        System.out.println(strA.contains(\"love\"));\r\n        findChar(strA,\" \");\r\n        fingLastChar(strA,\" \");\r\n        isStart(strB,\"http://\");\r\n        isInStart(strB,\"www.\",7);\r\n        isEnd(strB,\".top\");\r\n    }\r\n    //从头查询字串\r\n    public static void findChar(String strA,String strB) {\r\n        if (strA.indexOf(strB) != -1) {\r\n            System.out.print(\"查询的子串存在位置：\");\r\n            System.out.println(strA.indexOf(strB));\r\n        }\r\n    }\r\n    //从尾查询字串\r\n    public static void fingLastChar(String strA,String strB) {\r\n        if (strA.lastIndexOf(strB) != -1) {\r\n            System.out.print(\"查询的子串存在位置：\");\r\n            System.out.println(strA.lastIndexOf(strB));\r\n        }\r\n    }\r\n    //判断开头是否为指定字符\r\n    public static void isStart(String strA,String strB) {\r\n        System.out.println(strA.startsWith(strB) ? \"是以指定字符开头\" : \"不是以指定字符开头\");\r\n    }\r\n    //判断从x处是否为指定字符\r\n    public static void isInStart(String strA,String strB,int x) {\r\n        System.out.println(strA.startsWith(strB,x) ? \"是以指定字符开头\" : \"不是以指定字符开头\");\r\n    }\r\n    //判断结尾是否为指定字符\r\n    public static void isEnd(String strA,String strB) {\r\n        System.out.println(strA.endsWith(strB) ? \"是以指定字符结尾\" : \"不是以指定字符结尾\");\r\n    }\r\n\r\n/**\r\n *true\r\n *false\r\n *查询的子串存在位置：1\r\n *查询的子串存在位置：6\r\n *是以指定字符开头\r\n *是以指定字符开头\r\n *是以指定字符结尾\r\n */\r\n```\r\n\r\n## 字符串替换\r\n方法表示：\r\n|NO.|方法名称|类型|描述|\r\n|:----:|:----|:----:|:----|\r\n|1|public String replaceAll(String target,String replacement)|普通|全部替换|\r\n|2|public String replaceFirst(String regex,String replacement)|普通|替换首个|\r\n代码表示：\r\n```java\r\npublic class StringDemoA {\r\n    public static void main(String[] args) {\r\n        String str = \"I miss you\";\r\n        System.out.println(str.replaceAll(\" \",\"!\"));    //将空格全部变为！\r\n        System.out.println(str.replaceFirst(\" \",\"*\"));  //将首个空格变为*\r\n    }\r\n}\r\n/**\r\n *运行结果：\r\n *I!miss!you\r\n *I*miss you\r\n */\r\n```\r\n\r\n## 字符串拆分\r\n方法表示：\r\n|NO.|方法名称|类型|描述|\r\n|:----:|:----|:----:|:----|\r\n|1|public String[] split(String regex)|普通|按照指定的字符串进行全部拆分|\r\n|2|public String[] split(String regex,int limit)|普通|按照指定的字符串进行部分拆分，最后的数组长度就是由limit决定（如果能拆分的结果很多，数组长度才会由limit决定）|  \r\n代码表示：\r\n```java\r\npublic class StringDemoA {\r\n    public static void main(String[] args) {\r\n        String str = \"I miss you\";\r\n        allSplit(str,\" \");\r\n        System.out.println();\r\n        System.out.println(\"*********************\");\r\n        allSplit(str,\"\");\r\n        System.out.println();\r\n        System.out.println(\"*********************\");\r\n        partSplit(str,\" \",2);\r\n    }\r\n    //根据strB来将strA进行拆分（若strB为空那就按字符全拆分）\r\n    public static void allSplit(String strA,String strB) {\r\n        String result[] = strA.split(strB);\r\n        for (int x = 0; x < result.length; x++) {\r\n            System.out.print(result[x] + \"-\");\r\n        }\r\n    }\r\n    //将strA根据strB化成limit个字符串\r\n    public static void partSplit(String strA,String strB,int limit) {\r\n        String result[] = strA.split(strB,limit);\r\n        for (int x = 0; x < result.length; x++) {\r\n            System.out.print(result[x] + \"-\");\r\n        }\r\n    }\r\n}\r\n/**\r\n *运行结果：\r\n *I-miss-you-\r\n **********************\r\n *I- -m-i-s-s- -y-o-u-\r\n **********************\r\n *I-miss you-\r\n *Process finished with exit code 0\r\n */\r\n```\r\n注：如果遇到需要多次拆分的字符串我们可以运用for循环体系对拆分成的字符串组经行再次拆分;还有对于一些特殊的字符我们需要用“\\\\\\”进行转义!!!\r\n\r\n## 字符串截取\r\n方法表示：\r\n|NO.|方法名称|类型|描述|\r\n|:----:|:----|:----:|:----|\r\n|1|public String substring(int beginIndex)|普通|从指定索引截取到结尾|\r\n|2|public String substring(int beginIndex,int endIndex)|普通|截取指定索引范围中的子字符串|    \r\n字符串截取通常使用索引确定截取范围\r\n代码表示：\r\n```java\r\npublic class StringDemoB {\r\n    public static void main(String[] args) {\r\n        String strA = \"计算机科学与技术-photo-ppsong.jpg\"; //定义方式：院系-photo-姓名.jpg\r\n        String strB = \"软件工程-photo-bigliang.jpg\";\r\n        sperString(strA,\"-\",\"photo\",\".\");\r\n        sperString(strB,\"-\",\"photo\",\".\");\r\n    }\r\n\r\n    /**\r\n     * 因为在上面实例化的字符串院系，姓名长度不同而其他形式固定\r\n     * 我们要截取姓名但始末点无法确定\r\n     * 所以用索引确定起点和终点\r\n     */\r\n    public static void sperString(String str,String str1,String str2,String str3) {\r\n        int beginIndex = str.indexOf(str1,str.indexOf(str2)) + 1;\r\n        int endIndex = str.lastIndexOf(str3);\r\n        System.out.println(str.substring(beginIndex,endIndex));\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 其他操作方法\r\n可用方法：\r\n|NO.|方法名称|类型|描述|\r\n|:----:|:----|:----:|:----|\r\n|1|public static String format(String format,Object... args)|普通|根据指定结构进行文本格式化显示|\r\n|2|public String concat(String str)|普通|字符串的连接|\r\n|3|public String intern()|普通|字符串入池|\r\n|4|public boolean isEmpty()|普通|判断是否为空字符串（null）|\r\n|5|public int length()|普通|计算字符串的长度|\r\n|6|public String trim()|普通|去除左右的空格信息|\r\n|7|public String toUpperCase()|普通|字符串内容转大写|\r\n|8|public String toLowerCase()|普通|字符串内容转小写|\r\n补：首字母大写方法（系统中没有）\r\n```java\r\nclass StringUntil {\r\n    /**\r\n     *@Description:\r\n     *Param: str 要处理的字符串\r\n     *return: 首字母大写的结果\r\n     *Author: PPsong\r\n     *Date: 2019/11/3\r\n     */\r\n    public static String initcap(String str) {\r\n        if (str == null || \"\".equals(str)) {                      //如果为空直接输出\r\n            return str;\r\n        }\r\n        if (str.length() == 1) {                                   //如果字符串仅含一个字符直接大写\r\n            return str.toUpperCase();\r\n        }\r\n        return str.substring(0,1).toUpperCase() + str.substring(1);//将字符串截取成首字符和其他两段，将首字符大写后接上后续\r\n    }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 19:44 2019/11/3\r\n * @Modified By:\r\n */\r\npublic class StringDemoC {\r\n    public static void main(String[] args) {\r\n        System.out.println(StringUntil.initcap(\"ppsong\"));\r\n        System.out.println(StringUntil.initcap(\"p\"));\r\n    }\r\n}\r\n\r\n```',NULL,NULL,'1','2020-06-20 14:24:20','2020-06-20 14:24:23','2020-06-20 14:24:25',4),(4,'对象与参数数组',NULL,'ppsong',NULL,'\r\n# 参数数组（方法可变参数）\r\n为了方便开发者可以更加灵活地定义方法，避免方法中参数的执行限制。  \r\n## 定义方法：\r\npublic [static][final] 返回值类型 方法名称（参数类型...变量）{ //虽然定义方式改变了，但是本质还是数组\r\n     ...\r\n    [return [返回值]；]\r\n}\r\n```java\r\nclass ArrayUtilA {\r\n    public static int sum(int... data) {      //参数累加\r\n        int sum = 0;\r\n        for (int temp : data) {\r\n            sum += temp;\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 18:01 2019/10/28\r\n * @Modified By:\r\n */\r\npublic class JavaDemoD {\r\n    public static void main(String[] args) {\r\n        System.out.println(ArrayUtilA.sum(1,2,3,4));             //多个参数\r\n        System.out.println(ArrayUtilA.sum(new int[] {1,2,3,4})); //一个参数数组\r\n    }\r\n}\r\n\r\n```\r\n上述代码我们可以看出可变参数就是一个数组当然还有几个需要注意的地方：\r\n1.若一个方法中要接受多个数据类型那么可变参数要放到最后；\r\n2.一个方法只允许定义一个可变参数。  \r\n\r\n# 对象数组\r\n在java中所有的数据类型均可以定义为数组，引用数据类型也可以定义数组，这样的数组就称为对象数组。  \r\n## 定义方法：  \r\n1.对象数组动态初始化：\r\n                   类 对象数组名称[] = new 类 [长度]；\r\n2.对象数组静态初始化：\r\n                   类 对象数组名称[] = new 类 [] {实例化对象，实例化对象，···}\r\n### 代码范例：\r\n```java\r\nclass Student {                                                   //定义一学生类\r\n    private String name;\r\n    private int age;\r\n    public Student(String name,int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    //setter getter 无参构造省略\r\n    public String getInfo() {\r\n        return \"【姓名】：\" + this.name + \"【年龄】：\" + this.age;\r\n    }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 19:19 2019/10/28\r\n * @Modified By:\r\n */\r\npublic class JavaDemoA {\r\n    public static void main(String[] args) {\r\n        //动态初始化\r\n        Student stuA[] = new Student[3];\r\n        stuA[0] = new Student(\"张三\",18);\r\n        stuA[1] = new Student(\"李四\",19);\r\n        stuA[2] = new Student(\"王五\",20);\r\n        //静态初始化\r\n        Student stuB[] = new Student[] {\r\n                new Student(\"Mike\",18),\r\n                new Student(\"Ben \",19),\r\n                new Student(\"Bob \",20),\r\n        };\r\n        printStudent(stuA);\r\n        System.out.println(\"**********分割线***********\");\r\n        printStudent(stuB);\r\n    }\r\n    //定义对象输出方法\r\n    public static void printStudent(Student stu[]) {\r\n        for (int x = 0; x < stu.length; x++) {\r\n            System.out.println(stu[x].getInfo());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n```',NULL,NULL,'1','2020-06-20 14:25:53','2020-06-20 14:25:58','2020-06-20 14:26:01',4),(5,'Object类',NULL,'ppsong',NULL,'\r\n# Object类\r\n为了方便操作类型的统一，也为了方便为每一个类定义一些公共操作，所以专门设计了一个公共的Object父类（此类是唯一一个没有父类的类，但却是所有类的父类），所以利用class关键字定义的类全部都默认继承自Object类，即class Person{} = class Person extends Object{}也就是任何没有父类的类都可以向上转型为Object类。\r\nObject可以接受所有引用数据类型。（包括数组）。\r\n## 获取对象信息\r\nObject类中toString（）方法，而该方法是在直接进行对象输出时默认被调用的。\r\n覆写toString（）方法\r\n```java\r\nclass Person {\r\n    private String name;\r\n    private int age;\r\n    //无参构造\r\n    public Person() {\r\n        System.out.println(\"**********一个人产生***********\");\r\n    }\r\n    //双参构造\r\n    public Person(String name, int age) {\r\n        this();\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    //setter，getter省略\r\n    //覆写Object类中toString方法\r\n    public String toString() {\r\n        return \"【姓名】：\" + this.name + \"【年龄】：\" + this.age;\r\n    }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 15:15 2019/11/10\r\n * @Modified By:\r\n */\r\npublic class JavaDemo {\r\n    public static void main(String[] args) {\r\n        Person per = new Person(\"PPSong\",18);\r\n        System.out.println(per);            //输出per信息\r\n    }\r\n}\r\n\r\n```\r\n## 对象比较\r\n 标准方法：public boolean equals（Object obj）默认情况是对地址的比较\r\n 覆写equals（）方法\r\n```java\r\nclass Person {\r\n    private String name;\r\n    private int age;\r\n    //无参构造\r\n    public Person() {\r\n        System.out.println(\"**********一个人产生***********\");\r\n    }\r\n    //双参构造\r\n    public Person(String name, int age) {\r\n        this();\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    //覆写Object类中equals\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (!(obj instanceof Person)) {   //不属于同一个类\r\n            return false;\r\n        } else if (obj == null) {         //对象为空\r\n            return false;\r\n        } else if (this == obj) {         //对象是自己本身\r\n            return true;\r\n        } else {\r\n            Person per = (Person)obj;     //向下转型\r\n            return this.name.equals(per.name) && this.age == per.age;\r\n        }\r\n    }\r\n\r\n    //setter，getter省略\r\n    //覆写Object类中toString方法\r\n    public String toString() {\r\n        return \"【姓名】：\" + this.name + \"【年龄】：\" + this.age;\r\n    }\r\n}\r\n\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 15:15 2019/11/10\r\n * @Modified By:\r\n */\r\npublic class JavaDemo {\r\n    public static void main(String[] args) {\r\n                Person perA = new Person(\"PPSong\",18);\r\n                Person perB = new Person(\"PPSong\",18);\r\n                System.out.println(perA.equals(perB) ? \"两者相同\" : \"两者不同\");\r\n    }\r\n}\r\n/**\r\n *转型结果\r\n ***********一个人产生***********\r\n ***********一个人产生***********\r\n *两者相同\r\n */\r\n\r\n```\r\n',NULL,NULL,'1','2020-06-20 14:28:57','2020-06-20 14:28:59','2020-06-20 14:29:01',4),(6,'static关键字',NULL,'ppsong',NULL,'\r\n# static关键字\r\n   static是一个用于声明程序结构的关键字，此关键字可以用于全局属性和全局方法的声明，主要特点是可以避免对象实例化的限制，在没有实例化对象的时候直接进行类的访问。\r\n## static定义属性\r\n   类中static关键字开头的成员属性为公共属性，在没有实例化前也可以直接使用，也被称为静态成员属性。\r\n### 利用static创建一个学生类\r\n如下所示：\r\n``` java\r\nclass StudntA {                               //定义学生类\r\n    private String name;                     //【普通成员属性】姓名\r\n    private int age;                         //【普通成员属性】年龄\r\n    static String college = \"工学院\";         //【静态成员属性】学院（暂不封装）\r\n    public StudntA(String name, int age) {    //初始化普通成员属性\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    //setter getter 无参构造省略\r\n    public String getInfo() {                 //传出对象内容\r\n        return \"姓名： \" + this.name + \"  年龄： \" + this .age + \" 学院： \" + this.college;\r\n    }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 15:19 2019/10/27\r\n * @Modified By:\r\n */\r\npublic class JavaDemoB {\r\n    public static void main(String[] args) {\r\n        //实例化三个Student类的对象\r\n        StudntA stuA = new StudntA(\"张三\",20);\r\n        StudntA stuB = new StudntA(\"李四\",20);\r\n        StudntA stuC = new StudntA(\"王五\",20);\r\n        //学院改名为中兴通讯技术学院\r\n        StudntA.college = \"中兴通讯技术学院\";\r\n        //获取三个对象信息\r\n        System.out.println(stuA.getInfo());\r\n        System.out.println(stuB.getInfo());\r\n        System.out.println(stuC.getInfo());\r\n    }\r\n}\r\n```\r\n上述代码中学院属性为静态属性，可以做“牵一发而动全身”，我们可以避免过多的操作；静态的成员属性不受对象实例化的影响，可以完成一些需要共享的完成的操作，比如对象统计，自动命名等。\r\n\r\n## static定义方法\r\nstatic定义的方法可以在没有实例化对象的情况下调用。  \r\n注static方法与非static方法：  \r\n     1.static定义的方法不能调用非static的方法或属性；  \r\n     2.非static定义的方法可以调用static的属性或方法；  \r\n     3.使用static定义的属性和方法，可以在没有实例化对象的时候使用（也就是说static方法不能使用this关键字）  \r\n     4.非static定义的属性和方法，必须实例化对象之后才可以调用。   \r\n### 代码表示 \r\n在上述函数中对于static定义的college属性并未封装是因为没有static方法对静态成员属性college改值，下面我们对静态成员属性封装并用static属性改值  \r\n如下所示：\r\n``` java\r\nclass StudntB {                              //定义学生类\r\n    private String name;                     //【普通成员属性】姓名\r\n    private int age;                         //【普通成员属性】年龄\r\n    private static String college = \"工学院\";//【静态成员属性】学院\r\n\r\n    public StudntB(String name, int age) {   //初始化普通成员属性\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    /**\r\n     *定义static方法，可以修改静态属性college（在对象未实例化前）\r\n     * 注：static方法无法使用this关键字\r\n     * @param c 要修改的新内容\r\n     */\r\n    public static void setCollege(String c) {\r\n            college = c;\r\n    }\r\n    //setter getter 无参构造省略\r\n    public String getInfo() {                 //传出对象内容\r\n        return \"姓名： \" + this.name + \"  年龄： \" + this .age + \" 学院： \" + this.college;\r\n    }\r\n}\r\n\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 15:46 2019/10/27\r\n * @Modified By:\r\n */\r\npublic class JavaDemoC {\r\n\r\n    public static void main(String[] args) {\r\n        //修改college属性\r\n        StudntB.setCollege(\"中兴通讯技术学院\");\r\n        //实例化三个对象\r\n        StudntB stuA = new StudntB(\"张三\",20);\r\n        StudntB stuB = new StudntB(\"李四\",20);\r\n        StudntB stuC = new StudntB(\"王五\",20);\r\n        //获取三个对象信息\r\n        System.out.println(stuA.getInfo());\r\n        System.out.println(stuB.getInfo());\r\n        System.out.println(stuC.getInfo());\r\n    }\r\n}\r\n```\r\n',NULL,NULL,'1','2020-06-20 16:35:42','2020-06-20 16:35:48','2020-06-20 16:35:51',4),(7,'泛型',NULL,'ppsong',NULL,'\r\n# 泛型\r\n在Java语言中，为了方便接收参数类型的统一，提供了一个核心类Object，利用此类对象可以接收所有类型的数据。但是由于其所描述的数据范围过大，所以在实际使用中就会出现传入数据类型错误，从而引发ClassCastException异常。所以引入泛型技术。  \r\n##基本定义\r\n类的定义：class 名称<T>{};\r\n成员属性：权限 T 名称；\r\n方法：权限 T 方法名(){}；\r\n使用类：类名称<包装类> 名称 = new 类名称<包装类（可以省略）>()。\r\n```java\r\nclass Point<T> {\r\n   private T x;\r\n   private T y;\r\n   public void setX(T x) {\r\n      this.x = x;\r\n   }\r\n\r\n   public void setY(T y) {\r\n      this.y = y;\r\n   }\r\n\r\n   public T getX() {\r\n      return x;\r\n   }\r\n\r\n   public T getY() {\r\n      return y;\r\n   }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 18:10 2019/11/17\r\n * @Modified By:\r\n */\r\npublic class JavaDemoA {\r\n    public static void main(String[] args[]){\r\n       //实例化Point类对象，设置泛型标记T的目标数据类型\r\n       Point<Integer> point = new Point<Integer>();\r\n       //根据需求进行内容的设置，所有数据都通过Object接收\r\n       point.setX(10);\r\n       point.setY(20);\r\n       //从里面获取数据，由于返回值的是Object类型，所以必须进行强制性的向下转型\r\n       int x = point.getX();                             //【避免向下转型】获取x坐标原始内容\r\n       int y = point.getY();                             //【避免向下转型】获取y坐标原始内容\r\n       System.out.println(\"x坐标：\" + x + \"、y坐标：\" + y);\r\n    }\r\n}\r\n\r\n\r\n\r\n```\r\n## 泛型通配符\r\n### 使用“？”接收数据\r\n利用“？”表示的泛型类型只允许从对象中获取数据，而不允许修改数据。\r\n```java\r\nclass Messagea<T> {\r\n   private T content;\r\n   public void setContent(T content) {\r\n      this.content = content;\r\n   }\r\n\r\n   public T getContent() {\r\n      return this.content;\r\n   }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 18:10 2019/11/17\r\n * @Modified By:\r\n */\r\npublic class JavaDemoA {\r\n    public static void main(String[] args){\r\n      Messagea<String> msg = new Messagea<>();\r\n      msg.setContent(\"www.songjiabing.top\");\r\n      fun(msg);\r\n    }\r\n    public static void fun(Messagea<?> temp) { //输出信息，只允许取出不允许修改\r\n       System.out.println(temp.getContent());\r\n    }\r\n}\r\n\r\n\r\n```\r\n### 设置泛型上限\r\n？ extends 类：只能够使用当前类或当前类的子类设置泛型类型。\r\n例如：？ extends Number：可以设置Number或Number子类（比如Integer，Double）。\r\n```java\r\nclass Messagea<T extends Number> {               //定义泛型上限为Number\r\n   private T content;                            //泛型属性\r\n   public void setContent(T content) {\r\n      this.content = content;\r\n   }\r\n\r\n   public T getContent() {\r\n      return this.content;\r\n   }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 18:10 2019/11/17\r\n * @Modified By:\r\n */\r\npublic class JavaDemoA {\r\n    public static void main(String[] args){\r\n      Messagea<Integer> msg = new Messagea<>();  //Integer为Number子类\r\n      msg.setContent(10);                        //自动装箱\r\n      fun(msg);\r\n    }\r\n    public static void fun(Messagea<?> temp) { //输出信息，只允许取出不允许修改\r\n       System.out.println(temp.getContent());\r\n    }\r\n}\r\n\r\n```\r\n### 设置泛型下限\r\n？ super 类：只能够设置指定的类或指定类的父类。\r\n例如：？ super String：只能够设置String或String的父类Object。\r\n```java\r\nclass Messagea<T> {               //定义泛型上限为Number\r\n   private T content;                            //泛型属性\r\n   public void setContent(T content) {\r\n      this.content = content;\r\n   }\r\n\r\n   public T getContent() {\r\n      return this.content;\r\n   }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 18:10 2019/11/17\r\n * @Modified By:\r\n */\r\npublic class JavaDemoA {\r\n    public static void main(String[] args){\r\n      Messagea<String> msg = new Messagea<>();                \r\n      msg.setContent(\"PPSong的个人博客：songjiabing.top\");     //自动装箱\r\n      fun(msg);\r\n    }\r\n    public static void fun(Messagea<? super String> temp) { //输出信息，只允许取出不允许修改\r\n       System.out.println(temp.getContent());\r\n    }\r\n}\r\n\r\n```\r\n## 泛型接口\r\n泛型接口在进行子类定义时就有两种实现方式：在子类中继续声明泛型和子类中为父类设置泛型类型。\r\n```java\r\ninterface IMessage<T> {                      //定义一个泛型接口\r\n    public String echo(T msg);               //定义抽象方法\r\n}\r\n\r\nclass MessageImplA<S> implements IMessage<S> {//子类继续声明泛型类型\r\n\r\n    @Override\r\n    public String echo(S msg) {               //覆写方法\r\n        return \"【PPSong的个人博客】\" + msg;\r\n    }\r\n}\r\n\r\nclass MessageImplB implements IMessage<String> {//设置IMessage泛型类型\r\n\r\n    @Override\r\n    public String echo(String msg) {            //覆写方法\r\n        return \"【PPSong的个人博客】\" + msg;\r\n    }\r\n}\r\n/**\r\n * @Author: PPsong\r\n * @Description:\r\n * @Data: Created in 16:04 2019/11/18\r\n * @Modified By:\r\n */\r\npublic class JavaDemo {\r\n    public static void main(String[] args) {\r\n        IMessage<String> msgA = new MessageImplA<>();//实例化子类设置泛型\r\n        IMessage<String> msgB = new MessageImplB();  //实例化子类不设置泛型\r\n        System.out.println(msgA.echo(\"songjiabing.top\"));\r\n        System.out.println(msgB.echo(\"www.songjiabing.top\"));\r\n    }\r\n}\r\n/**\r\n *执行结果\r\n *【PPSong的个人博客】songjiabing.top\r\n *【PPSong的个人博客】www.songjiabing.top\r\n */\r\n\r\n```\r\n##泛型方法\r\n对于泛型，除了可以定义在类上之外，也可以在方法上进行定义，而在方法上定义泛型的时候，这个方法不一定非要在泛型类中定义。\r\n```java\r\npublic class JavaDemoA {\r\n    public static void main(String[] args){\r\n      Integer num[] = fun(1,2,3);\r\n        for (int temp : num) {                //foreach输出\r\n            System.out.print(temp + \" \");\r\n        }\r\n    }\r\n    //定义泛型方法，由于类中没有设置泛型，所以需要定义一个泛型标记，泛型的类型就是传递的参数类型\r\n    public static <T>  T[] fun(T... args) {              //可变参数\r\n      return args;\r\n    }\r\n}\r\n\r\n```',NULL,NULL,'1','2020-06-20 17:48:54','2020-06-20 17:48:57','2020-06-20 17:48:59',4);

/*Table structure for table `tb_article_tag` */

DROP TABLE IF EXISTS `tb_article_tag`;

CREATE TABLE `tb_article_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `article_id` bigint(20) NOT NULL COMMENT '文章ID',
  `tag_id` bigint(20) NOT NULL COMMENT '标签ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=36 DEFAULT CHARSET=utf8 COMMENT='文章&&标签关联表';

/*Data for the table `tb_article_tag` */

insert  into `tb_article_tag`(`id`,`article_id`,`tag_id`) values (29,1,5),(30,2,5),(31,5,4),(32,3,4),(33,6,4),(34,4,4),(35,7,4);

/*Table structure for table `tb_tag` */

DROP TABLE IF EXISTS `tb_tag`;

CREATE TABLE `tb_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `name` varchar(100) DEFAULT NULL COMMENT '标签名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT='标签表';

/*Data for the table `tb_tag` */

insert  into `tb_tag`(`id`,`name`) values (1,'随笔'),(4,'java基础'),(5,'SpringBoot'),(6,'helloworld');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
